# HTTP протокол

> **Рекомендуется** ознакомиться с [более полной статьей на вики](https://ru.wikipedia.org/wiki/HTTP).
> Данная статья скорее выжимка необходимого минимума из различных источников для понимания следующих частей.

**HTTP** *aka [HyperText](./html_pages.md) Transfer Protocol* - это **текстовый** протокол передачи данных прикладного уровня [ISO/OSI](../networks/iso_osi.md).  

HTTP это **клиент-серверная** технология, то есть подразумевается существование **клиента**, отправляющего запросы и **сервера**, запросы обрабатывающего.

Может использоваться как транспорт для других протоколов типа **SOAP**, **WebDAV** итд.

**HTTP** протокол не имеет промежуточных состояний между запросами. Любые представления о пользователях, сессиях, состояниях должны реализовываться на стороне участников обмена.

## Версии

Вдаваться в подробности незачем, но важно понимать, что версий больше одной и между ними есть разница. Разница между 1.0 и 1.1 на сегодняшний день не имеет значения, поскольку 1.0 уже вышел из употребления давно, однако на подходе(2018г.) HTTP 2.0, который уже сильно отличается от HTTP 1.0.  

### HTTP 0.9

Первая опубликованная спецификация протокола. На практике не использовалась.  

### HTTP 1.0

Первая реализация была основана на этой спецификации, опубликованой в 1996-ом году.  

### HTTP 1.1

Спецификация вышла в 1999г. Версия 1.0 была дополнена поддержкой **keep-alive**, то есть пересыл нескольких **http** запросов в рамках одного **TCP** соединения. Так же появился обязательный заголовок **Host**, передающий информацию о имени запрашиваемого хоста.  

### HTTP 2.0

Опубликована спецификация в 2018г. Протокол стал **бинарным**, поддерживает передачу в несколько потоков(до этого один поток на одно соединение), приоритеты, push-уведомления со стороны сервера.  
Плюс еще большое количество изменений, о которых будет написано отдельно.  

> Далее по-умолчанию считаем, что речь идет о версии 1.1, пока не будет написано иного. Т.к. версия 2.0 еще пока широко не распространена.  

## Структура

> Строки разделяются метасимволами \r\n,
> где \r - перевод каретки в начало строки,
> а \n перевод строки.

### Пример запроса

    GET /hello.htm HTTP/1.1
    User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)
    Host: mozilla.org
    Accept-Language: en-us
    Accept-Encoding: gzip, deflate
    Connection: Keep-Alive

### Пример ответа

    HTTP/1.1 200 OK
    Date: Mon, 27 Jul 2009 12:28:53 GMT
    Server: Apache/2.2.14 (Win32)
    Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
    Content-Length: 88
    Content-Type: text/html
    Connection: Closed

### Описание

Каждое сообщение **http** состоит из:

* Стартовой строки
* Заголовков (*headers*)
* Тела сообщения

В стартовой строке запроса указывается:

* используемый метод (капсом),
* [URI](./uri.md), то есть путь к ресурсу
* и версия протокола в формате `HTTP/X.X`.

Пример: `GET /something HTTP/1.1`

Далее обязательно следует строка с заголовком **Host**.

Пример: `Host: example.com`

В стартовой строке ответа:

* версия, формат как в запросе,
* код состояния (200, 404, 500, итд),
* пояснение (OK, NOT FOUND, итд).

Пример: `HTTP/1.1 200 OK`

### Методы HTTP

**HTTP метод** - это указание операции над ресурсом, записаное чем угодно, кроме упрвляющих символов. Однако в подавляющем большинстве используют строго определенные методы для упрощения поддержки и возможности использования сторонних решений(ваш кэп).

По спецификации протокола, сервер должен ответить статусом:

* `501 Not Implemented`, если метод распознать не удалось,
* `405 Method Not Allowed`, если метод неприменим к ресурсу.

В обоих случаях должен быть добавлен заголовок **Allow** со списком поддерживаемых методов.

Пример: `Allow: GET, POST, HEAD`

Далее список наиболее распространенных методов:

**OPTIONS** *aka Preflight* - запрос для определения возможностей. Ответ должен содержать заголовок **Allow**. Запрос и ответ могут содержать тело с указанием конкретики, но их поведение не определено спецификацией.

> Ответ на POST-запрос не должен кэшироваться по спецификации.

**GET** - используется для запроса указанного ресурса. Поддерживает передачу параметров(*aka querystring*), отделяемых от пути к ресурсу символом "**?**".

> Обычно принято не производить никаких изменений данных по GET запросу(почему, будет объяснено далее).

**HEAD** - аналогичен **GET**, но не имеет тела и нужен для получения метаданных ресурса, проверки его наличия или проверки наличия изменений.

**POST** - применяется для передачи пользовательских данных, в том числе файлов, в теле запроса ресурсу.

> Ответ на POST-запрос не должен кэшироваться по спецификации.

**PUT** - похож на **POST** во всем, кроме предназначения по методологии. Предполагается, что **POST** передает данные на обработку ресурсу, а **PUT** размещает данные по указанному пути.

> Ответ на POST-запрос не должен кэшироваться по спецификации.

**DELETE** - противоположность **PUT**, то есть удаляет указанный ресурс.

### Коды ответов

Коды ответа делятся на несколько групп:

* `1xx` - информационный
* `2xx` - успех в различной форме
* `3xx` - переадресация
* `4xx` - ошибка клиента
* `5xx` - ошибка сервера

> По спецификации ответы со статусом 3xx должны иметь заголовок **Location**, содержащий адрес ресурса, по которому нужно продублировать предыдущий запрос.  
> Ответы 4xx и 5xx должны в теле содержать пояснение в виде **HTML**-ки для пользователя, кроме ответа на запрос методом **HEAD**.

### Заголовки

Выглядят вот так: `Location: example.com`  

Каждый заголовок должен быть на отдельной строке, сама секция заголовков должна отделяться от тела сообщения минимум одной пустой строкой. Сами заголовки имеют обязательный формат в виде ключа до двоеточия и значения после.

Сами же заголовки делятся на несколько групп:

* Основные, они же обязательные. Например **Connection** cо значением **keep-alive** или **close**.
* Заголовки запроса. Например **Referer**, содержащий источники запроса.
* Заголовки ответа. Например **Allow**.
* Заголовки сущности. Например **Content-Type**.

> При этом описанный порядок нужно соблюдать.  
> Заголовки, помимо предопределенных спецификацией можно использовать и свои. Рекомендуется добавлять для них префикс **X-** дабы избежать конфликта.

### Тело сообщения

Используется для передачи объекта с запросом или ответом. О его наличии сигнализируют заголовки **Content-Length** или **Transfer-Encoding**.

> Тело сообщения не будет при использовании метода **HEAD** или при ответах со статусами: 1xx, 204(No Content), 304(Not modified). Во всех прочих случаях тело сообщения будет, даже с нулевой длиной.  
> Все прочие случаи непредусмотрены спецификацией.

## Механизмы HTTP протокола

### Range Requests

Сервер может уведомить клиента о поддержке **Range requests** через заголовок **Accept-Ranges**.  
`Accept-Ranges: bytes`  

При поддержке **Range requests** клиент может запрашивать данные с байтовым сдвигом "от начала" файла, указав заголовок **Range**.  
`Range: bytes=88080384-`

В ответе с сервера в свою очередь будет содержаться **Content-Range**, указывающий запрошенную часть:  
`Content-Range: bytes 88080384-160993791/160993792`  
Так же ответ будет со статусом 206(Partial Content).  

Есть два типа скачивания данных таким методом: с определенным заголовком **Content-Length** и без него. В первом случае клиент поделит размер запрошенного файла на диапазоны и скачает их поочередно. Во втором случае будет все то же самое, но клиент будет продолжать попытки до тех пор, пока не получит 416(Requested Range Not Satisfiable).  

### Conditional Requests

При наличии кэша на клиенте, можно указать заголовок **If-Modified-Since** с указанием даты попадания файла в кэш. В ответ с сервера придет ответ со статусом 304(Not Modified), если запрошенный ресурс не менялся после указанной даты, во всех противных случаях ответ будет идентичен обычному **GET**, в том числе если в заголовке будет нарушен формат или некорректные данные.

Пример: `If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT`

### Basic auth

**Basic auth** - это механизм авторизации средствами **HTTP** протокола.  
Алгоритм работает следующим образом:  

* клиент запрашивает ресурс,
* сервер отвечает статусом 401(Authorization Required), с заголовком **WWW-Authenticate**,
* клиент повторяет запрос, добавляя заголовок **Authorization** с логином в открытом виде и паролем кодированным **[BASE64](./base64.md)**, то есть практически в открытом виде.

Если логин с паролем верны, то сервер уже ответит 200(OK) и общение будет продолжено, а если нет, то сервер ответит 401 и все пойдет по новой.

> По спецификации ответ 401 от сервера должен содержать поясняющий HTML документ.

## HTTP 2.0 подробно

Отличие от HTTP 1.1:  

* Протокол стал бинарным
* Сжатие данных в заголовках
* Устранена проблема **head-of-line**(когда потеря пакета делала невозможным получения следующих), однако устранили на уровне прикладном, на транспортном все еще актуально ([TCP](../networks/iso_osi.md)). (на этом можно не заостряться)
* Мультиплексирование запросов в одном **TCP** соединении
* Приоритеты скачивания
* Возможность слать с сервера еще не запрошенные данные (**server-push**)
* Браузеры поддерживают **HTTP/2.0** только по шифрованному соединению

Не смотря на все описанные прелести **HTTP/2.0** он еще не пошатнул позиции **HTTP/1.1** потому, что имеет несколько важных недостатков.  

* Нет еще полной поддержки приоритетов
* Популярные веб-сервера не поддерживают **server-push**, например **nginx**
* **Proxy-pass** не умеет в **HTTP/2.0**

> Proxy-pass - это механиз передачи запроса от одного сервера другому.

[← Назад](../README.md)