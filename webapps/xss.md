# Cross-Site Scripting aka XSS

**XSS** - атака, смысл которой во внедрении вредоносного кода в страницу уязвимого ресурса для последующего взаимодействия посетителя сайта и сервером атакующего.  

## Классификация

**XSS** делят по вектору:  

* **reflected** - внедрение происходит на основе переданных в запросе данных, например в **querystring**

`http://example.com/method?vuln=<script>alert();</script>`
  
`<div>{{ vuln }}</div>`

* **stored** - внедрение просиходит однократно атакующим, с последующим сохранением на сервере. Например в теле сообщения на форуме.

Также **XSS** делят по способу воздействия:

* **активные** - выполняющие необходимые действия при загрузке, не требуя дополнительных действий пользователя.
* **пассивные** - ожидают некоторых действий пользователя для срабатывания, например наведение курсора на элемент.

## Причины возникновения

* Баги браузера
* Отсутствие экранирования или фильтрации пользовательских данных
* Через другую уязвимость, например **SQL**-инъекцию
* Подмена кодировки страницы, например на **UTF-7**, если она явно не указана

## Защита

1. Явно указывать кодировку страниц
2. Экранировать и фильтровать пользовательский ввод
3. По-возможности использовать **CSP**, вынося **JS** в подключаемые файлы

При манипуляциях с **DOM** на клиенте использовать безопасные методы:  

    node.textContent = userInput;
    element.setAttribute(attrName, userInput);
    window.encodeURIComponent(userInput);
    element.style.property = userInput;

## Эксплуатация

Обход защиты, если таковая имеется. Можно попробовать обойти фильтры, кодируя различным образом пейлоад.  
Примеры:  

`alert(String.fromCharCode(120,97,107,110,101,116,46,114,117))`

`alert(unescape(/%78%61%6b%6e%65%74%2e%72%75/.source))`

`<IMG SRC=&!#106;&!#97;&!#118;&!#97;&!#115;&!#99;&!#114;&!#105;&!#112;&!#116;&!#58;&!#97;&!#108;&!#101;&!#114;&!#116;&!#40;&!#39;&!#120;&!#97;&!#107;&!#110;&!#101;&!#116;&!#46;&!#114;&!#117;&!#39;&!#41;>`

`<IMG SRC=&!#0000106a&!#0000118&!#0000097&!#0000115&!#0000099&!#0000114&!#0000105&!#0000112&!#0000116&!#0000058&!#0000097&!#0000108&!#0000101&!#0000114&!#0000116&!#0000040&!#0000039&!#0000120&!#000097&!#0000107&!#0000110&!#0000101&!#0000116&!#0000046&!#0000114&!#0000117&!#0000039&!#0000041>`

`<IMG SRC="Ja    va    sc    ri    pt    :    al    er    t(    'me    ssa    ge'    )">`

`<META HTTP-EQUIV="refresh" CONTENT="0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgneGFrbmV0LnJ1Jyk8L3NjcmlwdD4=">`

Если допускается пользовательская разметка, то перебрать атрибуты, обработчики событий.  

При успешной эксплуатации можно привязать, к примеру, **CSRF**.

[Еще способы обхода фильтров от OWASP](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)

## PS: XSS-Auditor

> С версии 7.0.542.0

У Chrome браузера есть встроенный механизм защиты от **XSS**, в рамках которого он меняет контент, блокирует выполнение подозрительного **JS**, блокирует работу с куками, если они используются в запросах не так, как принято, закрывает теги и вообще пакостит как может, исходя из своих соображений.

> Может ловить false-positive
> Если это происходит, то разработчик скорее всего написал не шибко безопасный код, склонный к утечкам данных

Для отключения нужно запустить Chrome с флагом `--disable-xss-auditor`, без этого искать уязвимости напрасно, потому как дырка может быть, но именно в хроме ее не удастся найти.  
Включается форсировано и выключается заголовком `X-XSS-Protection` со значениями `1` и `0` соответственно.  

Есть у него полезный функционал: репортить о своих срабатываниях, для этого нужно указать **URI** в заголовке:  
`X-XSS-Protection: 1; reeport=http://myhost.com/reportURL`

А еще он легко обходится:  

* Игнорирует содержимое `<svg></svg>`, а внутри может быть **JS**
* Часто игнорирует XSS, если внедряемый контент из нескольких строк

[← Назад](../README.md)